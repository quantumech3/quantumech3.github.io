[
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Blogs",
    "section": "",
    "text": "Matrix multiplication from scratch\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nJan 9, 2024\n\n\nScott Burgert\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Website!\n\n\n\n\n\n\n\npersonal\n\n\n\n\n\n\n\n\n\n\n\nDec 25, 2023\n\n\nScott Burgert\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/welcome-to-my-website/index.html",
    "href": "posts/welcome-to-my-website/index.html",
    "title": "Welcome To My Website!",
    "section": "",
    "text": "Introduction\nHello! Welcome to my website. I will be posting blogs about things I find interesting. I try my best to keep up to date in the latest research in Graphics. I discovered that I get more out of what I read when writing about it after. So thats why I write blogs. I am also trying to learn more about the process of research itself and I see blogging as an excersize to push me to grow in that sense.\nI can‚Äôt promise a regular upload schedule because I am balancing this with my classes, but I will try my best.\nThis blog is dedicated to showing you who I am though. You won‚Äôt see much about my technical accomplishments here unfortunately because I want to keep this blog brief, and I feel my resume should be sufficient if you want my technical achievements. I will also primarily be writing about technical topics after this blog so you will get a good sense of my professional interests then.\n\n\nMy Creepy Profile Picture\n\n\n\nMy profile picture\n\n\nSigh, I got some explaining to do I guess‚Ä¶ This profile pic is a 3D scan of my face that was taken when I was doing conformal mapping research with a professor and his team a few years ago. The first day I walked into this lab, his PhD student sat me down on a chair facing a few cameras. I had no idea what was going on. I figured they were taking my picture, but I didn‚Äôt know that they were getting a LiDAR scan of my face! You can see the utter confusion in my eyes above.\nIts the initiation into the group. Every member of the team gets his/her face scanned. I knew from that moment on that this screenshot of my face in MeshLab had to be my profile picture. Ever since then, whenever I got the chance to bring a friend to the lab, I would always sit them down, tell them nothing, scan their face, and watch their reaction after. Its just so funny.\n\n\nMy Previous Blogs\n\nCutting a Square into 3rds\n\nSince the project I was on concluded, I have been spending my time writing blogs. I originally was on Medium, but they took away the ability to theme my blogs, like the one above, the way I wanted üò≠. So I decided to make my own website with no paywalls or restrictions.\n\n\nOther hobbies\nI am an ‚Äúartist‚Äù. In particular, I like photography, drawing, 3D modeling, and digital music production. Ill only show 2 of these here so I don‚Äôt drag out the blog for too long.\n\nMusic production\n\nMy SoundCloud\n\nSo.. this is now the part where I desparately plug my SoundCloud like a true professional. BUT WAIT, DONT GO! I promise it gets better from here!\nI like making music because its one of the most abstract forms of art. When you draw something for example, you start that drawing with a goal: to make a coherent depiction of the object your trying to capture. This is not true for music though. You can come in with an idea, but thats different from a concrete objective for what your making. That makes this medium unique from the rest of them.\nThere are 2 musicians I think you should check out if your looking to learn digital audio production:\n\nAndrew Hwang: He is a YouTuber who makes a wide range of music. You may have heard of him, but if you haven‚Äôt then you really should check him out because his tutorials are excellent and I learned alot of what I know from him.\nAu5: He makes dubstep tracks. I don‚Äôt actually play instruments myself but I am familiar enough in synthwork and sound design. But he is one of the few artists who make sounds that I truely don‚Äôt know how to reproduce. He makes excellent breakdowns on YouTube of each of his songs though.\n\n\n\nPhotography\nGraphics is my primary interest, but one of the reasons that I got into computer vision was because of photography. I probably burnt you out with my rant in the last section so I will just show you a bunch of photos I took:\n\n\n\nSunset at Pinnacle Mountain\n\n\n\n\n\nNight sky in Vermont\n\n\n\n\n\nFlowers\n\n\n\n\n\nCandy Ocean in Port Jefferson\n\n\nAlmost all my best photos are taken at sunset I think. Atleast in my opinion. But heres a photo that breaks the trend:\n\n\n\nPuppy marble\n\n\n\n\n\nConclusion\nI showed you some of my hobbies, and blogging experience. Most of the blogs from here on are going to be technical, and alot more interesting in my opinion. But I figured it would be good to show you my personality a little in case your interested.\nTill the next blog! üê∂"
  },
  {
    "objectID": "posts/matrix-multiplication/index.html",
    "href": "posts/matrix-multiplication/index.html",
    "title": "Matrix multiplication from scratch",
    "section": "",
    "text": "Introduction\nHello again! Last semester I was a TA for CSE 101 at SBU. CSE 101 is the intro course for computer science. I noticed that iteration and lists were one of the most challenging concepts to teach to the students in my recitation. All of my students ended up doing well though, so I want to write something that will help people outside of that course that are new to programming. All my students were taking linear algebra at the time I was teaching this, so basic knowledge of matrix multiplication is assumed.\nI generally think that CS is best taught top down. So that is how I will teach this. First, I will show you the code that performs matrix multiplication to make you curious, then once we have established a goal to work toward, I will teach you the foundations you need to understand this code. Then I will walk you through the implementation step by step.\n\n\nProblem statement\nWe want to write a program that prints \\(C\\) in the calculation \\(A B = C\\), where \\(A,B\\) and \\(C\\) are matrices. \\(A\\) and \\(B\\) are assumed to be a valid matrix multiplication, meaning that \\(A\\) is a \\(m \\times n\\) matrix, and \\(B\\) is a \\(n \\times k\\) matrix.\n\n\n\nThe Code\nI will start by defining the matrices we are going to multiply.\n\nMaking our test case\nHeres the code we will examine throughout this blog that performs this multiplication. a_mat and b_mat are the matrices we are multiplying, and c_mat is the resulting matrix. A general rule I teach my students is that before you implement anything, you should always make a test case first. So lets do that.\nWe will get into this matrix multiplication shortly, but some things you should know for now are:\n\nA list in Python holds a bunch of elements.\nYou can think of it as a bunch of variables in 1 variable. If we have 3 variables a=1, b=2 and c=3, we could replace this with the list abc = [1, 2, 3]. Then a[0]=1, a[1]=2, a[2]=3 respectively.\nLists can contain other lists. So if we had a=[1,2,3], b=[4,5,6], and c=[7,8,9], we could replace these variables with 1 variable like so: abc = [[1,2,3],[4,5,6],[7,8,9]]. Then abc[0]=[1,2,3], abc[1]=[4,5,6], and abc[2]=[7,8,9].\n\nKnowing this, lets define the matrices we will multiply in Python. Don‚Äôt worry if this confuses you still. We will go over it in detail:\n\na_mat = [[1,2,3],\n         [4,5,6]]\n\nb_mat = [[9,8],\n         [7,6],\n         [5,4]]\n\nc_mat = [[0,0],\n         [0,0]]\n\nI initialize the values of c_mat to be all 0s for now since we will set them later. A multiplication of a \\(m \\times n\\) and a \\(n \\times k\\) is a \\(m \\times k\\). Since a_mat is a \\(2 \\times 3\\), and b_mat is a \\(3 \\times 2\\), our resulting matrix, c_mat, will be a \\(2 \\times 2\\).\nSo we have just coded our matrices, but to make this a test case we need to know what we want our code to set c_mat to. That way we know whether our code is doing the right thing. If you were implementing this on your own, you might make more then 1 test case to really make sure your code is solid.\nIn this case, we expect\nc_mat = [[38,32]\n         [101,86]]\nonce we have ran our multiplication code. You can verify it yourself with this website which multiplies 2 matrices for you.\n\n\nThe multiplication code\nI will define some constants to make the code easier to read later.\n\nM = len(a_mat)\nN = len(b_mat)\nK = len(b_mat[0])\n\nHere is the code that performs the matrix multiplication and sets each value of c_mat:\n\nfor i in range(M):\n    for j in range(N):\n        for k in range(K):\n            c_mat[i][k] += a_mat[i][j] * b_mat[j][k]\n\n\nc_mat\n\n[[38, 32], [101, 86]]\n\n\nWe can see that this indeed matches our test case from earlier. So we know these ‚Äúmagic‚Äù lines of code work, but how?\n\n\n\nHow to read my blogs\nI strongly believe in active learning. When I taught my class, I would constantly quiz my students to make sure they understood what I was saying. Answering questions pokes holes in your understanding and makes you aware of what you need to improve in. It also improves your memory retension. You are much less likely to forget, and will get much more out of what I have written in this post if you follow along like I describe below.\nAs you read this post, I encourage you to try running this code yourself, change things, and experiment. will give you some ideas for things to try on your own as we go. I will also frequently test your understanding by asking questions and hiding the answer from you in a foldable cell.\nTo make sure you are understanding what I am saying, lets try this format out right now before we continue.\nWhat is the value of M in our code?\n\n\nCode\n2\n# a_mat is a M x N matrix, as discussed in the problem statement. \n# In our test case, c_mat is a 2x3 matrix, so M = 2\n\n\nWhat is the value of N in our code?\n\n\nCode\n3\n# a_mat is a M x N matrix, as discussed in the problem statement. \n# In our test case, c_mat is a 2x3 matrix, so N = 3\n\n\nSuppose we have the code\na = 4\nb = 5\nc = 6\nWhat is the value of b?\n\n\nCode\n5\n\n\nEquivalently, we can write our code like this and it will do the same thing as above, except with different variable names:\na0, a1, a2 = 4, 5, 6\nWhat is the value of a1?\n\n\nCode\n5\n# a1 is the same as b between this question and the last one. \n\n\nNow suppose we write code to do the same thing again, but with lists as discussed in the previous section.\na = [4,5,6]\nWhat is a[1]?\n\n\nCode\n5\n# The code is equivalent to the last 2 questions. a[1] = a1 = b. \n\n\nLast question, I promise, then we will dive deeper into the code I introduced.\na = [4,5,6]\nWhat is a[2]?\n\n\nCode\n6\n# From our previous questions,\n# a[2] = a2 = c\n\n\nExperiment: Try running the following code below. What does it output? Next, try changing index and see what happens.\na = [1,2,3]\n\nindex = -1\n\nprint(a[index])\nNow that you understand how to read my blogs, lets move on and discuss lists.\n\n\nWhat is a list?\nA list is made up of elements, each of which have an index associated with them. We already saw this before when I was asking you questions actually in the previous section.\n\nElement: A value inside of the list\nIndex: A number that allows you to access a particular value in the list\n\nFor\na = [4, 5, 6]\na is our list in this case. We can access the element 4 with a[0]. In other words, 0 is the index of the element 4.\nIn general, to access an element in a list arr at index i, we would do this with the following syntax:\narr[i]\n\n\n\nList indexing in Python\n\n\nIn Python, positive indices start at the beginning and go toward the end of the list, and negative indices start at the end and move toward the beginning of the list.\nIts important to note that not all languages support using negative indices inside of lists. Its a nice quirk of Python.\nConcider the code below. What is x[1]?\nx = [9, 2, 3, 6, 4]\n\n\nCode\nx[1] = 2\n# Very important: The first element in our list always starts at 0!!!!!!\n\n\nWhat is the index of the element 6 in x?\n\n\nCode\nx[3] = 6\n# Therefore the index of 6 is 3.\n\n\nWhat is the value of x[-4]?\n\n\nCode\nx[-4] = 2\n\n\nx has 5 elements. So it has a length of 5. In general, we can get the length of any list in Python with the len() function.\n\nx = [9, 2, 3, 6, 4]\nlen(x)\n\n5\n\n\nElements of a list can be of any type, even within the same list, not just integers like i‚Äôve shown so far. But the same rules apply for the indexing.\n\nitems = [\"I\", True, \"ly\", \"would\", \"like\", \"some\", 3.14159]\n\nLets index some values in items\n\nitems[1]\n\nTrue\n\n\n\nitems[3]\n\n'would'\n\n\nNow its your turn. What is items[-1]?\n\n\nCode\nitems[-1] = 3.14159\n\n\nIn general, arr[-1] will get you the element at the end of the list. But suppose we didn‚Äôt have negative indexing. For example, many other languages such as C++ and Java do not have this luxury. So its good to know another way to do this.\nIf we have \\(n\\) elements in a list, then we want to get the \\(n^{th}\\) element of that list since that will be at the end.\nSo would arr[len(arr)] get you the last element of arr? As always when programming, lets try it and see what happens.\n\narr = [1,2,3,4,5,6]\narr[len(arr)]\n\nIndexError: list index out of range\n\n\nNo! It won‚Äôt‚Ä¶. huh. In fact it threw an error. Why?\nRemember, indices always start at 0! Lets simplify the problem a bit and then you will see why this causes an error to happen. Lets define a smaller list.\n\na = [1,2]\n\n\n\n\nWhen IndexError occurs\n\n\nHopefully by now you should see that if we only use positive indices, the last element of a would be at index 1. So a[len(a)] = a[2] which intern is greater then the greatest index in the list, causing an IndexError. In general, if we have indices that are outside of the range of elements in the array, then we will crash the program.\nAlso notice how the last element of a has index 1, but len(a) returns 2 since there are 2 elements. We are always going to be ‚Äú1 off‚Äù from the last element. To fix this, we can just subtract 1.\nThe following code will always get the last element of an array:\n\na[len(a) - 1]\n\n2\n\n\n\nitems = [\"I\", True, \"ly\", \"would\", \"like\", \"some\", 3.14159]\n\nitems[len(items) - 1]\n\n3.14159\n\n\nWe can see that this indeed works, not only with a, but with any list.\nWhat would items[-len(items) - 1] do?\n\n\nCode\nitems[-len(items)] = items[-8] = IndexError\n# Throws an error. Our list is 7 elements long. \n# So -8 is \"one off\" before the first element.\n\n\nWhat would items[-len(items)] do?\n\n\nCode\nitems[-len(items)] = items[-7] = 'I'\n# It will always return the first element. \n# Unlike positive indices, negative indices start at -1.\n\n\nWe can also assign to the values of lists the same way we would with variables:\n\nitems[2] = 'changed'\nitems\n\n['I', True, 'changed', 'would', 'like', 'some', 3.14159]\n\n\nWe can see that we changed the 3rd element of items in the statement above to changed. All of the same indexing rules apply.\n\n\n2D lists in Python\nRecall that lists can contain any datatype. This means that we can have a list of lists! In fact, we already saw this when we were implementing our test case for the matrix multiplication. Lets concider our definition of a_mat again:\n\na_mat = [[1,2,3], [4,5,6]]\n\nIndexing these lists works the same as with any other datatype. a_mat[0] will get you the first list, and a_mat[1] will get you the second list.\n\na_mat[0]\n\n[1, 2, 3]\n\n\n\na_mat[1]\n\n[4, 5, 6]\n\n\nWhat is the value of b_mat[1] from our matrix multiplication test case?\nb_mat = [[9,8],\n         [7,6],\n         [5,4]]\n\n\nCode\nb_mat[1] = [7,6]\n\n\nWhat is the value of b_mat[-1] from our matrix multiplication test case?\n\n\nCode\nb_mat[-1] = [5,4]\n\n\nSince we are obtaining a list as our element, we can index what we obtain to get a specific value of that sublist. For example, b_mat[0][1] will get the element at \\(B_{0,1}\\), which is 8.\n\n\nb_mat[0][1]\n\n8\n\n\nBelieve it or not, we can actually now start to understand the matrix multiplication code. Now we can understand how we are getting the M, N, and K variables.\n\n\nM = len(a_mat)\nN = len(b_mat)\nK = len(b_mat[0])\n\nInside of the matrix multiplication code, I first define these constants which describe the widths and heights of the matrices: \\(A = m \\times n\\), \\(B = n \\times k\\), \\(C = m \\times k\\)\nWe can think of len(a_mat) to be the number of lists in a_mat, which intern are the number of rows in a_mat.\nWe can get the number of columns by getting the number of rows in \\(B\\) with len(b_mat) since \\(B\\) is required to have the same height as \\(A\\)‚Äôs width, else its not a valid matrix multiplication.\nTo get the number of columns in \\(B\\), we can examine the length of one of its rows with len(b_mat[0]). We don‚Äôt have to use the \\(0^{th}\\) row. We can get the length of any row and it will be the same. For example, the following code would get the same value for K, no matter the size of the matrix:\n\nK = len(b_mat[-1])\n\nWe now have the tools to write a basic matrix multiplication program‚Ä¶ technically. We can now hard code the formula for multiplying a 2x2 matrix for example:\n\na_mat = [[1,2],\n         [3,4]]\nb_mat = [[0,1],\n         [1,0]]\n\nc_mat = [[a_mat[0][0]*b_mat[0][0] + a_mat[0][1]*b_mat[1][0], a_mat[0][0]*b_mat[0][1] + a_mat[0][1]*b_mat[1][1]],\n         [a_mat[1][0]*b_mat[0][0] + a_mat[1][1]*b_mat[1][0], a_mat[1][0]*b_mat[0][1] + a_mat[1][1]*b_mat[1][1]]]\n\n\nc_mat\n\n[[2, 1], [4, 3]]\n\n\nAnd we see that it clearly does work. But the code is incredibly hard to read and we can only do it for fixed dimensions. If we try to change the shape of our matrices, our program will break.\nSo there is another piece of the puzzle we need to implement our matrix multiplication program: iteration!\n\n\nLets pause for a second\nWe just went over alot. We are half way there. Don‚Äôt worry. If you look at where the scroll bar is on the page you can see there isnt alot left to go.\nWhen I was learning how to use arrays for the first time, I couldn‚Äôt make heads or tails of it. It seemed like there are so many ‚Äúweird‚Äù rules, exceptions, and concepts I need to master such as starting at 0, out of bounds indexing and more. Learning how to code is hard for everyone. So its important to realize that your not the only one going through this.\nWhen I was TAing for CSE 101, I could see visible frustration on my students faces when I was helping them out during office hours. But they also got through this. Your no different then them. The most important advice that I can give you for CS, as general and corny as it may sound, is to not give up.\nAnother piece of advice I would give to you is to take a break once in a while. Sometimes after a long study session, when I take a break, the answer just comes to me. I have observed this in my students as well. So maybe concider taking a 10 minute break before you read the rest of this blog just to let what you‚Äôve learned so far sink in.\nOnce your ready, lets move on to iteration.\n\n\nWhat is a for loop?\nLets simplify by examining 1 part of the matrix multiplication problem. Suppose I have a list containing numbers, and I want to sum them all together:\n\narr = [1,2,3]\n\nsum = arr[0] + arr[1] + arr[2]\n\nprint(sum)\n\n6\n\n\nWe could do it like we did above: We add each element by manually indexing them. However, like our matrix multiplication problem, this solution becomes extremely tedious for large lists, and impossible if we don‚Äôt know the length of the list beforehand.\nLets redefine arr with another element added and you‚Äôll see what I mean.\n\narr = [1,2,3,4]\n\nsum = arr[0] + arr[1] + arr[2]\n\nprint(sum)\n\n6\n\n\nOur sum should be 10. No matter, we can fix this by manually adding another term to our sum:\n\narr = [1,2,3,4]\n\nsum = arr[0] + arr[1] + arr[2] + arr[3]\n\nprint(sum)\n\n10\n\n\nNow it works! But suppose I remove an element from arr. So we now have the code\narr = [1,2,3]\n\nsum = arr[0] + arr[1] + arr[2] + arr[3]\n\nprint(sum)\nWhat do you think will happen?\n\nIndexError\nPrints 6\nPrints 10\n\n\n\nCode\nIndexError\n# We have 3 elements. Our maximum index is 2. \n\n\nWe can fix this problem with for loops, which will allow us to vary the amount of terms in our sum. Lets see how to write code to sum the elements of a list, even when we don‚Äôt know what the length of it is!\nThis code\narr = [1,2,3]\n\nsum = arr[0] + arr[1] + arr[2]\n\nprint(sum)\nWill produce the same output as:\n\narr = [1,2,3]\n\nsum = 0\n\nsum += arr[0]\nsum += arr[1]\nsum += arr[2]\n\nprint(sum)\n\n6\n\n\nWhich will do the same thing as:\n\narr = [1,2,3]\n\nsum = 0\n\nfor i in range(len(arr)):\n    sum += arr[i]\n\nprint(sum)\n\n6\n\n\nfor i in range(N):\n    # insert code here to run N times\nDo you see whats happening? A for loop takes the indented block of code, and runs it N times, setting the value of i in each iteration to successively increasing values starting at 0, and ending at N - 1.\nWhat will the following code print?\nfor i in range(5):\n    print(i)\n\n\nCode\n0\n1\n2\n3\n4\n# You may have thought that it would print 5, that is a common mistake. \n# Our loop ends at N - 1, \n# just like indices of list with N elements ends at N - 1.\n\n\nThe reason we can replace\nsum += arr[0]\nsum += arr[1]\nsum += arr[2]\nwith\nfor i in range(len(arr)):\n    sum += arr[i]\nis that the following happens:\n\nThe for loop sets i = 0\nsum += arr[i] =&gt; sum += arr[0] is ran\nThe for loops sets i = 1\nsum += arr[i] =&gt; sum += arr[1] is ran\n\nAnd so on all the way up to i = len(arr) - 1, when sum += arr[len(arr) - 1], in which the loop terminates and moves to the next line of code after it.\nFor loops solve our problem because no matter what len(arr) is, we will always have the correct amount of terms. This is important because we are using for loops to sum each of the products, for each of the entries in c_mat.\nExperiment: Instead of summing the elements of arr, modify the code to take the product of all the elements.\nFill in the blanks to sum every odd index of arr:\nsum = 0\nfor i in range(___):\n    sum += arr[___]\n\n\nCode\nsum = 0\nfor i in range(len(arr) // 2):\n    sum += arr[2*i + 1]\n\n\nFill in the blanks to sum all diagonal elements in arr, starting from the top left:\narr = [[1,2],\n       [3,4]]\n\nsum = 0\nfor i in range(len(arr)):\n    sum += arr[__][__]\n\n\nCode\nsum = 0\nfor i in range(len(arr)):\n    sum += arr[i][i]\n\n\nOk, now we are going to get a little harder. It‚Äôs OK if you don‚Äôt get this one. It will simaltaneously give you a better understanding of our matrix multiplication problem, and give you more practice with for loops.\nFill in the blanks to sum all of the numbers in arr:\narr = [[1,2],\n       [4,5]]\n\nsum = 0\n\nfor i in range(__):\n    sum += arr[__][i % len(arr)]\n\n\nCode\narr = [[1,2],\n       [4,5]]\n       \nsum = 0\n\nfor i in range(len(arr) * len(arr)):\n    sum += arr[i // len(arr)][i % len(arr)]\n\n\nFill in the blanks to sum all of the numbers in arr (note the extra column):\narr = [[1,2,3],\n       [4,5,6]]\n\nsum = 0\n\nfor i in range(__):\n    sum += arr[__][i % len(arr[0])]\nHint: Think about the definition of M, N, and K\n\n\nCode\narr = [[1,2,3],\n       [4,5,6]]\n\nsum = 0\n\nfor i in range(len(arr) * len(arr[0])):\n    sum += arr[i // len(arr[0])][i % len(arr[0])]\n\n\nSo this is a fun excersize, but the reality is that working with lists like this is going to get very complicated when we are juggling 3 matrices at once. There is a better way to think about iterating through 2d lists.\nJust like we can have lists inside of lists, we can also have for loops inside of for loops. Another way to sum all of the elements of arr would be the following code:\n\nsum = 0\n\nfor row in range(len(arr[0])):\n    sum += arr[0][row]\n\nfor row in range(len(arr[0])):\n    sum += arr[1][row]\n\nprint(sum)\n\n21\n\n\nYou can probably already see the problem with this approach though. Our code requires exactly 2 rows to work properly. So we can replace the code above with\n\nsum = 0\n\nfor col in range(len(arr)):\n    for row in range(len(arr[0])):\n        sum += arr[col][row]\n\nprint(sum)\n\n21\n\n\nIts the same idea as when you learned we could nest lists together. In general, if something can contain itself, then it opens up whole new dimensions of possibility!\nWe don‚Äôt have to stop here. We can nest as many for loops as we want. Same for lists, although for our problem we are only dealing with matrices which are 2d lists.\nYou have now learned about iteration. You now have the foundation to write the matrix multiplication code\n\n\nPutting it all together\nThe keyword is you. You are going to write it. I will ask a series of questions to guide you in the right direction, and then by the end of this section, you will fully understand the code I showed you at the beginning of this blog post.\n\nM = len(a_mat)\nN = len(b_mat)\nK = len(b_mat[0])\n\na_mat = [[1,2],\n         [3,4]]\nb_mat = [[0,1],\n         [1,0]]\n\nc_mat = [[a_mat[0][0]*b_mat[0][0] + a_mat[0][1]*b_mat[1][0], a_mat[0][0]*b_mat[0][1] + a_mat[0][1]*b_mat[1][1]],\n         [a_mat[1][0]*b_mat[0][0] + a_mat[1][1]*b_mat[1][0], a_mat[1][0]*b_mat[0][1] + a_mat[1][1]*b_mat[1][1]]]\n\n\n‚ÄúAnd we see that it clearly does work. But the code is incredibly hard to read and we can only do it for fixed dimensions. If we try to change the shape of our matrices, our program will break.‚Äù\n\nIn a previous section, we got to a partial solution for our problem statement. We found out how to obtain M, N and K and we hard coded a way to multiply a 2x2 matrix. But we can do better. We need to generalize to any 2 valid matrices for multiplication.\nc_mat is going to be a 2d list of 0s that we are going to sum to. Remember the sum variable from the previous section? We are basically going to use c_mat as a 2d list of them. It is OK to look at the original code to answer the following questions. The goal of these questions is to get you to analyze the code for yourself.\nHow many for loops will we need for our multiplication?\n\n\nCode\n3\n# We need 2 for loops to iterate over the elements of a_mat and b_mat, \n# and a 3rd for loop to keep track of where we are summing in c_mat\n\n\nWhat should we replace __ * __ with?\n\na_mat = [[1,2,3],\n         [4,5,6]]\n\nb_mat = [[9,8],\n         [7,6],\n         [5,4]]\n\nc_mat = [[0,0],\n         [0,0]]\n\nfor i in range(N):\n    for j in range(K):\n        for k in range(M):\n            c_mat[k][j] += __ * __\n\n\n\nCode\nfor i in range(N):\n    for j in range(K):\n        for k in range(M):\n            c_mat[k][j] += a_mat[k][i] * b_mat[i][j]\n\n\nCongratulations! You now understand how to implement matrix multiplication in Python.\n\n\nConclusion\nI am still trying to figure out how I want to write my blogs. I wanted to start off with something simple. I am discovering that the best blogs are not the ones that invent some new novel concept, but rather are the ones that can explain a concept as clearly as possible. As by ‚ÄúAbout‚Äù page says, I am interested in Computer Graphics, Vision, and Deep Learning. Future blogs will cover more advanced concepts, however matrix multiplication lies at the heart of all these fields. So I figured this was a good place to start.\nThis is a topic that by far the most people in CSE 101 struggled with. So I hope that future people who take this course will see this blog, and realize that although this stuff is complicated, its not out of their grasp.\nTill the next blog! üêç"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "Comp Sci. + Applied Math Double Major @ SBU\nStrong interest in Computer Graphics, Vision, and Deep Learning."
  }
]